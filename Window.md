```PARTITION, array (функции) ```
# Задача 1
**Описание задачи:**

Для таблицы Титаник. Давайте посмотрим кто из пассажиров заселился в несколько номеров. Для этого

Разобьем колонку ```Cabin``` на массив значений
Отсортируйте по размеру массива по убыванию
Подсказка, вам может помочь данный раздел. Например из ```C23 F C25 C27``` получаем ```[23, "F", 25, 27]```

**Формат ответа:**

В качестве ответ впишите номер билета по которому куплено больше всего номеров.

# Решение
```sql
SELECT 
    Name, 
    Ticket, 
    length(CASE WHEN Cabin = '' THEN [] ELSE splitByChar(' ', Cabin) END) AS ArrayLength
FROM default.titanic
ORDER BY ArrayLength DESC
```

# Задача 2
**Описание задачи:**

У нас есть таблица с событиями пользователей в мобильном приложении, но как это обычно бывает в жизни, не все события доходят до нашей таблицы, и это большая проблема, так как мы не можем корректно оценить последовательность действий совершенных пользователем. 
Однако для части событий мы можем решить эту проблему.
Допустим наш пользователь пытается купить что то на сайте, и мы точно знаем что он не сможет сделать новый шаг без завершения предыдущего.
Исходя из этого мы можем сгенерировать последовательность шагов для каждого пользователя (в свое время я решал такую задачу для заполнения пропусков в таблице чтобы потом это можно было использовать для построения прогнозов).

Ваша задача в этом задании заполнить данные которые пропущены, у нас есть ```uid``` (пользователь) и ```step_``` (имя шага, события). Шаги помечены номерами, они соответствуют последовательности действий, то есть идут друг за другом. 
Но часть из них пропущена, нужно их проставить. Нам известно что у нас 9 пользователей, и такая последовательность шагов

1. step a (1 шаг)
2. step b
3. step c
4. step d
5. step e
6. step f
7. step g
8. step w (последний шаг)
9. 
У каждого пользователя максимальный шаг свой! В задании не нужно использовать ```CROSS JOIN```

**Формат ответа:**

В качестве ответа нужно указать сумму по столбцу ```UID```
# Решение
```sql
WITH 
    user_steps AS (
        SELECT 
            UID,
            groupArray(step) AS gr_steps
        FROM default.events
        GROUP BY UID
    )
SELECT
    COUNT(UID) AS user_count 
FROM
(
    SELECT
        UID,
        arrayFilter(x -> NOT has(gr_steps, x), ['step a', 'step b', 'step c', 'step d', 'step e', 'step f', 'step g', 'step w']) AS missing_steps,
        arraySort(arrayDistinct(arrayConcat(gr_steps, missing_steps))) AS all_steps
    FROM user_steps
) -- выходит 9 почему то
```
# Задача 2
**Описание задачи:**

Для таблицы Титаник, посчитайте шансы выжить для каждого пользователя исходя из его пола и класса 

**Формат ответа:**

В качестве ответа впишите имя пассажира у которого шанс выжить больше всего, отсортируйте по имени если таких пассажиров несколько ```[A -> Z]```. Нельзя использовать ```JOIN```
Только оконные функции.
# Решение
```sql
WITH surival_stats AS (
    SELECT 
        Name, 
        Sex, 
        Pclass,
        SUM(Survived) OVER (PARTITION BY Sex, Pclass) AS survived_sum,
        COUNT(Name) OVER (PARTITION BY Sex, Pclass) AS all_people_per_class
    FROM default.titanic
)
SELECT 
    Name,
    (survived_sum / all_people_per_class) AS chance_to_survive
FROM surival_stats
ORDER BY chance_to_survive DESC, Name
LIMIT 1
```
