# Словари в ClickHouse

Словари — это мощный инструмент при работе в ClickHouse, который упрощает операции с дополнительными данными. Представьте, что у вас есть таблица:

| id | country_code |
|----|--------------|
| 1  | RU          |
| 2  | UK          |
| 3  | US          |

Чтобы получить не только код страны, но и название, логично было бы сделать `JOIN` с такой таблицей:

| country_code | country_name     |
|--------------|------------------|
| RU           | Russia           |
| UK           | United Kingdom   |
| US           | United States    |

Однако это может быть неудобно. Что, если я скажу, что можно выполнить эту операцию одной строкой? Есть два способа сделать это: **внешний словарь** и **движок `JOIN()`**.

## Внешний словарь

### Описание из документации:
В ClickHouse можно подключать собственные словари из разных источников данных. Источником данных для словаря может быть локальный файл, HTTP(s) ресурс или другая СУБД.

### Особенности
- Полностью или частично хранит словари в оперативной памяти.
- Периодически обновляет их и подгружает отсутствующие значения.
- Конфигурируется через XML файлы.

### Преимущества
Помимо того, что словари хранятся в оперативной памяти, они позволяют не тратить время на построение хеш-таблицы для операции `hash-join`. Вместо этого мы можем использовать готовую хеш-таблицу, что экономит время. Например, выполнить `JOIN` можно с помощью такой команды:

```sql
dictGet('dict_name', attr_names, id_expr)
```
## JoinGet
Интересно, не правда ли? К сожалению показать возможности внешних словарей достаточно сложно в рамках данного курса, но мы можем воспользоваться движком JOIN, он ведет себя примерно также как и внешние словари, также лежит целиком в памяти как хэш таблица, и также позволяет выполнять операцию JOIN одной строкой.

```joinGet(join_storage_table_name, `value_column`, join_keys)```

Давайте попробуем проверить это на практике. Создадим таблицу:
```sql
CREATE TABLE join_table(
   id UInt32, 
   val String
) 
ENGINE = Join(ANY, LEFT, id)
SETTINGS join_use_nulls=1
```

Интерес для нас здесь представляет только строка
```sql
ENGINE = Join(ANY, LEFT, id);
```

Первый аргумент показывает строгость ```JOIN```, второй аргумент это механика объединения, и третий это ключ по которому будет происходить объединение. Ключ должен быть уникальным на таблицу!

Вставим данные

```sql
INSERT INTO join_table VALUES (1,'a')(2,'b')(3,'c');
```

Теперь создадим таблицу с которой будет происходить JOIN
```sql
CREATE TABLE table1(
   id1 UInt32, 
   val1 String
) 
ENGINE = Log;
```

# Вставим данные
```INSERT INTO table1 VALUES (1,'aa')(3,'bb')(4,'cc');```

Теперь напишем запрос на объединение данных:

```sql
SELECT id1, joinGet('join_table', 'val', id1)
FROM table1
```

Как видите данные объединились, мы смогли достаточно просто выполнить операцию ```JOIN```
# Задача
 данном задании вам нужно будет воспользоваться готовым кодом и просто объединить 2 таблицы по ключу. Как бонус вы получите большой словарь с данными по странам который я когда то давно собирал для своих проектов.

Таблица JOIN
```sql
CREATE TABLE geo 
( 
    country_code String, 
    iso3 String, 
    iso_numeric String, 
    fips String, 
    country String, 
    capital String, 
    country_amplitude String, 
    region String, 
    sub_region String, 
    area Int64, 
    population Int64, 
    continent String, 
    currency_code String, 
    currency_name String, 
    languages String, 
    geonameid String, 
    neighbours String 
) 
ENGINE = Join(ANY, LEFT, country_code);
```

Вставим данные в таблицу, запрос на вставку скачайте тут. 

Теперь создадим вторую таблицу к которой будем джойнить.

```sql
CREATE TABLE log
( 
    event_time DateTime, 
    user_id String, 
    country_code String
) 
ENGINE = Log
```

Вставим данные в таблицу, запрос на вставку скачайте тут.

Напишите запрос которые объединит данные с помощью ```joinGet``` и выведет размер популяции для каждой строки, в качестве ответа вставьте сумму по получившемуся столбцу.

# Решение
```sql
SELECT 
    SUM(joinGet('default.geo', 'population', log.country_code)) AS total_population
FROM 
    default.log
```

