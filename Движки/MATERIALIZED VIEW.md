# Теория
Материализованное представление помогает решить много задач и обойти ряд ограничений с которыми вы столкнетесь. Давайте сначала посмотрим как он работает, а затем я расскажу как и зачем его можно применить.

Представьте что у вас есть таблица в которую вы **вставляете данные**, и что если я вам скажу что на каждый такой insert вы можете обработать кусочек вставляемых данных, и положить в другую таблицу, при этом данные в первой таблице останутся в том виде в котором вы их туда отправили.

**Основные особенности и преимущества MATERIALIZED VIEW:**
- **Повышение производительности**: материализованный вид сохраняет результат запроса, обновляя его автоматически при изменении данных в исходной таблице. Это ускоряет доступ к предварительно рассчитанным данным.

- **Автоматическое обновление**: когда данные в исходной таблице обновляются, материализованный вид также обновляется автоматически, поддерживая актуальные результаты.

- **Оптимизация агрегированных запросов**: полезен для случаев, когда запросы часто выполняют одни и те же агрегации (например, суммирование, подсчёт и т.д.). Материализованный вид позволяет хранить результаты таких вычислений заранее.

- **Хранение денормализованных данных**: можно использовать для создания объединённых (join) и денормализованных представлений, которые упрощают доступ к сложным структурам данных.

Пример создания MATERIALIZED VIEW
```sql
CREATE MATERIALIZED VIEW my_view
ENGINE = AggregatingMergeTree() -- Можно выбрать другой движок
POPULATE AS
SELECT
    user_id,
    count() AS visits,
    sum(total) AS total_spent
FROM orders
GROUP BY user_id;
```

Теперь давайте создадим MV таблицы которые будут как бы смотреть в sales
```
CREATE MATERIALIZED VIEW sales1
ENGINE = MergeTree() 
         PARTITION BY toYYYYMM(sale_date) 
         ORDER BY (sale_date)
AS SELECT *
FROM sales
```
Как можете заметить синтаксис весьма прост, разберем его чуть подробнее. Первым делом прописываем название нашей MV

```CREATE MATERIALIZED VIEW sales1```
Затем прописываем движок, сортировку и партиционирование, как у обычных таблиц. В нашем примере мы поменяли ключ сортировки!

```
ENGINE = MergeTree() 
         PARTITION BY toYYYYMM(sale_date) 
         ORDER BY (sale_date)
 ```
Затем выполняем запрос на чтение к вставляемым данным. Именно так, этот запрос будет использован только к тем данным которые прям сейчас мы пытаемся вставить. В данном случае мы просто читаем их как есть.

```AS SELECT *
FROM sales
```
**Когда я рекомендую использовать данную таблицу, и что я делать не рекомендую:**

Рекомендую:

- Создать дополнительную таблицу с другим ключем сортировки 
- Повесить MV над сырыми данными, например json, который будет разбираться
- Можно использовать другие движки семейства MergeeTree такие как ReplacingMergeTree или AggregatingMergeTree

Не рекомендую:

- Не стоит создавать много MV смотрящих в одну таблицу, иначе вы рискуете столкнуться с тем что вставка данных в таблицу порождает много дополнительных операций insert , это будет нагружать систему
- Старайтесь производить небольшие изменения таблиц, не нужно полностью пересобирать всё
# Задача
На одном из прошлых уроков, мы с вами работали с **json**. В данном уроке я вам предлагаю использовать MV для разбора json.

Итак, у нас есть ```null``` таблица, такие таблицы не хранят данные, но в них может смотреть **MV** чтобы разбирать поступающий поток событий. В такую таблицу льется поток json, и мы хотим повесить **MV** чтобы она разбирала json и вставляла его отдельно по колонкам. Вам необходимо написать запрос на создание такой **MV**.

Код создающий NULL таблицу:

```CREATE TABLE raw (json String) ENGINE = Null;```

После того как вы напишите запрос, вставьте данные в таблицу raw в качестве ответа я жду от вас код MV а также скриншот что вставленные данные разбились по колонкам. Партиционирование и сортировку можете выбрать на свое усмотрение.

```INSERT INTO raw (json) FORMAT JSONAsString {"id":1,"name":"agqjGPFWQL","value":0.4147567279516813,"is_active":true,"key":"590","list":[10,24,35,14,12]},{"id":2,"name":"jquAteQEnl","value":0.8693090338928422,"is_active":true,"key":"422","list":[33,68,50,82,42]},{"id":3,"name":"lLnNYOndXF","value":0.81953610746394,"is_active":true,"key":"202","list":[60,48,29,38,0]},{"id":4,"name":"jIxTqCPoQM","value":0.3049173457433211,"is_active":true,"key":"319","list":[62,75,26,19,77]},{"id":5,"name":"lfRfKKJuzL","value":0.6913571966267789,"is_active":true,"key":"551","list":[79,78,56,85,60]},{"id":6,"name":"qpnEHsTOsk","value":0.01984812089081356,"is_active":false,"key":"864","list":[16,90,92,3,5]},{"id":7,"name":"IGjyyDKIKX","value":0.5269701687049049,"is_active":false,"key":"410","list":[80,39,49,90,94]},....```

Формат вставляемых данных

```{"id":1,"name":"agqjGPFWQL","value":0.4147567279516813,"is_active":true,"key":"590","list":[10,24,35,14,12]}```
В качестве ответа введите sum(is_active) 
# Решение
```
-- таблица  принимает JSONы
CREATE TABLE raw (json String) ENGINE = Null


-- Создание таблицы parsed_data для хранения разобранных данных
--каждый элемент JSON будет сохранён в своей колонке
CREATE TABLE parsed_data
(
    id UInt32,
    name String,
    value Float64,
    is_active UInt8,
    key String,
    list Array(Int32)
)
ENGINE = MergeTree()
ORDER BY id;

 

--MV автоматически парсит JSON из raw и сохраняет разобранные данные в таблице parsed_data

CREATE MATERIALIZED VIEW parse_json_mv TO parsed_data
AS
SELECT
    JSONExtractUInt(json, 'id') AS id,
    JSONExtractString(json, 'name') AS name,
    JSONExtractFloat(json, 'value') AS value,
    toUInt8(JSONExtractBool(json, 'is_active')) AS is_active,
    JSONExtractString(json, 'key') AS key,
    JSONExtract(json, 'list', 'Array(Int32)') AS list
FROM raw

--вставляем JSON-данные в raw, и MV автоматически перенесёт их в parsed_data в разобранном виде
INSERT INTO raw (json) FORMAT JSONAsString
{"id":1,"name":"agqjGPFWQL","value":0.4147567279516813,"is_active":true,"key":"590","list":[10,24,35,14,12]};......

--сумма
SELECT sum(is_active) AS active_sum
FROM parsed_data
```
 